#!/usr/bin/env node

var infuse      = require("../lib/infuse.js"),
    FS          = require("fs"),
    Path        = require("path"),
    isArray     = Array.isArray,
    packagePath = Path.join(__dirname, "..", "package.json"),
    packageInfo = JSON.parse(FS.readFileSync(packagePath, "utf8")),
    pad         = Array(4).join(" "),
    opts        = {
        infile: {
            string: "INPUT_PATH",
            position: 0,
            help: "File to read."
        },
        outfile: {
            string: "[OUPUT_PATH]",
            position: 1,
            help: "File to write. If not specified, write to STDOUT."
        },
        nodeLibPaths: {
            string: "-L, --node-lib PATH",
            list: true,
            help: "PATH to your local library directory of node builtin modules."
        },
        nominify: {
            string: "-N, --no-minify",
            flag: true,
            help: "Do not minify the output."
        },
        force: {
            string: "-F, --force",
            flag: true,
            help: "If OUTPUT_PATH already exists, overwrite it."
        },
        definitions: {
            string: "-D, --define SYMBOL[=VALUE]",
            help: "Replace all instances of the specified SYMBOL with VALUE.",
            list: true
        },
        definitionsModule: {
            string: "-d, --define-module NAME",
            help: "Will load the NAMEd module (as per require()) and 'define' all exported properties.",
            list: true
        },
        embed: {
            string: "-E, --embed",
            help: "Embed the infused modules as strings and lazy-evaluate them when required.",
            flag: true
        },
        reserved: {
            string: "-R, --reserved WORD",
            help: "A comma-delimited list of reserved words that should NOT be mangled.",
            list: true
        },
        readStdin: {
            string: "-S, --stdin",
            help: "Read INPUT_FILE from STDIN instead of a file. Base directory for resolving requires will be considered the current working directory.",
            flag: true
        },
        watchFile: {
            string: "-w, --watch",
            help: "Watch INPUT_FILE. Whenever it is modified, re-infuse with the same command",
            flag: true
        },
        dumpAst: {
            string: "-A, --dump-ast",
            help: "Dump out the generated Abstract Syntax Tree.",
            flag: true
        },
        version: {
            string: "-V, --version",
            help: "Print the version information and exit.",
            flag: true,
            callback: function () {
                return "version " + packageInfo.version;
            }
        },
        help: {
            string: "-h, --help",
            help: "Print this.",
            flag: true
        }
    },
    options = require("nomnom").
        script("infuse").
        options(opts).
        parse(),
    input       = "",
    outputFile  = options.outfile,
    inputFile   = options.infile,
    defModule   = options.definitionsModule,
    defs        = options.definitions,
    inStream,
    outStream,
    definitions,
    reserved,
    cwd = process.cwd()
;

function doInfuse (src) {
    outStream.write(
        infuse(
            src,
            {
                definitions: definitions || null,
                reserved:    reserved || null,
                embed:       options.embed,
                libPaths:    options.nodeLibPaths || null,
                nominify:    options.nominify,
                dumpAst:     options.dumpAst
            }
        ),
        "utf8"
    );
}
//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------
if (defModule || defs) {
    definitions = {};

    // Require any definition modules
    if (defModule) {
        defModule = isArray(defModule) ? defModule : [defModule];
        defModule.forEach(function (name) {
            var mod;
            name = name.indexOf(".") === 0 ?
                Path.join(cwd, name) :
                name;
            mod = require(name);
            Object.keys(mod).forEach(function (k) {
                definitions[k] = mod[k];
            });
        });
    }

    // Individual definitions
    if (defs) {
        defs = isArray(defs) ? defs : [defs];
        defs.forEach(function (def) {
            var delimIdx = def.indexOf("="),
                key, val
            ;
            
            if (~delimIdx) {
                key = def.slice(0, delimIdx);
                val = def.slice(delimIdx+1);
                try {
                    val = JSON.parse(val);
                }
                catch (e) {
                    // ignore...
                    // console.log("Could not parse '" + key + "'. " + e);
                }
            }
            else {
                key = def;
                val = true;
            }
            
            // console.log(key + " = " + val + " (" + (typeof val) + ")");
            
            definitions[key] = val;
        });
    }
}

// Collect reserved words
if (options.reserved) {
    reserved = options.reserved.reduce(function (t, c) {
        t.push.apply(t, c.split(","));
        return t;
    }, []);
}

try {
    if (options.watchFile) {
        console.log("Watching file: " + inputFile);
        options.force = true;
        FS.watchFile(inputFile, function (curr, prev) {
            var cmtime = curr.mtime.getTime(),
                pmtime = prev.mtime.getTime()
            ;
            
            if (cmtime > pmtime) {
                console.log("Re-infusing: " + inputFile);
                doInfuse(inputFile);
            }
        });
    }

    if (options.readStdin) {
        inStream = process.stdin;
        inStream.setEncoding("utf8");
        
        if (inputFile && !outputFile) {
            outputFile = inputFile;
            inputFile = null;
        }
    }
    
    if (inputFile && !Path.existsSync(inputFile)) {
        throw "Can not read from '" + inputFile + "'. File does not exist.";
    }

    if (outputFile) {
        if (Path.existsSync(outputFile) && !options.force) {
            throw "Can not write to '" + outputFile + "'. File already exists. " +
                "Use -F, --force to overwrite.";
        }

        outStream = FS.createWriteStream(outputFile, {encoding: "utf8"});
    }
    else {
        outStream = process.stdout;
        outStream.setEncoding("utf8");
    }
    
    if (inStream) {
        inStream.on("data", function (d) {
            input += d;
        });
        
        inStream.on("end", function () {
            doInfuse(input);
        });
        
        inStream.resume();
    }
    else {
        doInfuse(inputFile);
    }

}
catch (e) {
    process.stderr.write("ERROR: " + (e.msg || e) + "\n");
    if (e.stack) {
        process.stderr.write(e.stack.join("\n") + "\n");
    }
}
