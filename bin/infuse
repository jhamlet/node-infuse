#!/usr/bin/env node

var infuse      = require("../lib/infuse.js"),
    FS          = require("fs"),
    Path        = require("path"),
    isArray     = Array.isArray,
    packagePath = __dirname + "/../package.json",
    packageInfo = JSON.parse(FS.readFileSync(packagePath, "utf8")),
    pad         = Array(4).join(" "),
    opts        = {
        infile: {
            string: "[INPUT_PATH]",
            position: 0,
            help: "File to read. If not specified, read from STDIN."
        },
        outfile: {
            string: "[OUPUT_PATH]",
            position: 1,
            help: "File to write. If not specified, write to STDOUT."
        },
        nodeLibPaths: {
            string: "-L, --node-lib PATH",
            list: true,
            help: "PATH to your local library directory of node builtin modules."
        },
        nominify: {
            string: "-N, --no-minify",
            flag: true,
            help: "Do not minify the output."
        },
        force: {
            string: "-F, --force",
            flag: true,
            help: "If OUTPUT_PATH already exists, overwrite it."
        },
        definitions: {
            string: "-D, --define SYMBOL[=VALUE]",
            help: "Replace all instances of the specified SYMBOL with VALUE.",
            list: true
        },
        definitionsModule: {
            string: "-d, --define-module NAME",
            help: "Will load the NAMEd module (as per require()) and 'define' all exported properties.",
            list: true
        },
        reserved: {
            string: "-R, --reserved WORD",
            help: "A comma-delimited list of reserved words that should NOT be mangled.",
            list: true
        },
        version: {
            string: "-V, --version",
            help: "Print the version information and exit.",
            flag: true,
            callback: function () {
                return "version " + packageInfo.version;
            }
        },
        help: {
            string: "-h, --help",
            help: "Print this.",
            flag: true
        }
    },
    scriptHelpTxt = ["NOTE ON RETURN VALUES FROM --define's: ",
        "Currently in UglifyJS, the return value of defines have to be in the ",
        "form of the AST. i.e: [\"num\", 9].",
        "",
        "AST value references:",
        "         true: [\"name\", \"true\"]",
        "        false: [\"name\", \"false\"]",
        "    undefined: [\"name\", \"undefined\"]",
        "       string: [\"string\", \"foo\"]",
        "       number: [\"num\", 9]"
    ].reduce(function (t, c, i) { return (t + (i > 0 ? pad : "") + c + "\n"); }, ""),
    options = require("nomnom").
        script("infuse").
        options(opts).
        help(scriptHelpTxt).
        parse(),
    input       = "",
    outputFile  = options.outfile,
    inputFile   = options.infile,
    defModule   = options.definitionsModule,
    defs        = options.definitions,
    inStream,
    outStream,
    definitions,
    reserved,
    cwd = process.cwd()
;

//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------
if (defModule || defs) {
    definitions = {};

    // Require any definition modules
    if (defModule) {
        defModule = isArray(defModule) ? defModule : [defModule];
        defModule.forEach(function (name) {
            var mod;
            name = name.indexOf(".") === 0 ?
                Path.join(cwd, name) :
                name;
            mod = require(name);
            Object.keys(mod).forEach(function (k) {
                definitions[k] = mod[k];
            });
        });
    }

    // Individual definitions
    if (defs) {
        defs = isArray(defs) ? defs : [defs];
        defs.forEach(function (def) {
            var delimIdx = def.indexOf("="),
                key, val
            ;
            
            if (~delimIdx) {
                key = def.slice(0, delimIdx);
                val = def.slice(delimIdx+1);
                try {
                    val = JSON.parse(val);
                }
                catch (e) {
                    // ignore...
                    // console.log("Could not parse '" + key + "'. " + e);
                }
            }
            else {
                key = def;
                val = true;
            }
            
            // console.log(key + " = " + val + " (" + (typeof val) + ")");
            
            definitions[key] = val;
        });
    }
}

// Collect reserved words
if (options.reserved) {
    reserved = options.reserved.reduce(function (t, c) {
        t.push.apply(t, c.split(","));
        return t;
    }, []);
}

try {
    if (!outputFile && inputFile) {
        outputFile = inputFile;
        inputFile = null;
    }

    if (inputFile && !Path.existsSync(inputFile)) {
        throw "Can not read from '" + inputFile + "'. File does not exist.";
    }

    if (inputFile) {
        inStream = FS.createReadStream(inputFile, {encoding: "utf8"});
    }
    else {
        inStream = process.stdin;
        inStream.setEncoding("utf8");
    }

    if (outputFile) {
        if (Path.existsSync(outputFile) && !options.force) {
            throw "Can not write to '" + outputFile + "'. File already exists. " +
                "Use -F, --force to overwrite.";
        }

        outStream = FS.createWriteStream(outputFile, {encoding: "utf8"});
    }
    else {
        outStream = process.stdout;
        outStream.setEncoding("utf8");
    }

    inStream.on("data", function (txt) {
        input += txt;
    });

    inStream.on("end", function () {
        outStream.write(infuse(input, {
            definitions: definitions || null,
            reserved: reserved || null,
            nominify: options.nominify,
            nodeLibPaths: options.nodeLibPaths || null
        }), "utf8");
    });

    inStream.resume();
}
catch (e) {
    process.stderr.write("ERROR: " + (e.msg || e) + "\n");
    if (e.stack) {
        process.stderr.write(e.stack.join("\n") + "\n");
    }
}
