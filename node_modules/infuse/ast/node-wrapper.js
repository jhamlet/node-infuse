/*globals nodeWrapper*/

var Proteus     = require("proteus"),
    stringify   = require("./stringify"),
    isArray     = Array.isArray,
    CHILD_KEYS  = require("./node-child-keys")
;

/**
 * Wraps a node-like object with utility functionality.
 * 
 * The node becomes the prototype object of the returned wrapper instance.
 * Properties applied to the wrapper will be applied to the prototype node
 * whenever the wrapper's "update" method is called.
 * 
 * @function nodeWrapper
 * @param {Object} node the node to wrap
 * @param {Object} parent optional, the node's parent node.
 */
function nodeWrapper (node, parent) {
    return Object.defineProperties(
        Object.create(node, nodeWrapper.properties),
        {
            /**
             * A reference to the actual node, and in this case, the prototype
             * of this instance
             * 
             * @property {Object} __node__
             * @private
             */
            __node__: { value: node },
            /**
             * The parent node of this node.
             * 
             * @property {Object} parent
             */
            parent: { value: parent, enumerable: true }
        }
    );
}

module.exports = Proteus.merge(nodeWrapper, {
    
    properties: {
        /**
         * @property {Boolean} isWrapper
         * @default true
         */
        isWrapper: { value: true, enumerable: true },
        /**
         * Update the node with the passed properties.
         * 
         * We only copy over non-wrapper properties to the node subject.  If
         * the props object turns out to be an instance of a node-wrapper,
         * we delete any passed keys from the wrapper, so they only exist
         * on the subject.  They'll still be available on the wrapper, since
         * the wrapper's prototype is also the subject.
         * 
         * @method update
         * @param {Object} props the properties to update on the node
         * @returns {Object} the current instance
         */
        update: { value: function (props) {
            var properties = nodeWrapper.properties,
                subject = this.__node__,
                isSelf
            ;
            
            props = props || this;
            isSelf = props === this;
            
            Object.keys(props).forEach(function (key) {
                if (!properties.hasOwnProperty(key) && key !== "parent") {
                    subject[key] = props[key];
                    if (isSelf) {
                        delete props[key];
                    }
                }
            });
            
            return this;
            
        }, enumerable: true },
        /**
         * Return a JSON string of the node subject
         * 
         * @method inspect
         * @returns {String}
         */
        inspect: { value: function () {
            return JSON.stringify(this.subject, null, 4);
        }, enumerable: true },
        /**
         * The keys for this node's children
         * 
         * @property {Array[String]} childKeys
         */
        childKeys: { get: function () {
            return CHILD_KEYS[this.type];
        }, enumerable: true },
        /**
         * The individual child nodes, conveniently wrapper-ized.
         * 
         * @property {Object} childNodes
         */
        childNodes: { get: function () {
            var node = this,
                childKeys = this.childKeys,
                children = []
            ;
            
            childKeys.forEach(function (key) {
                var child = node[key];
                
                if (isArray(child)) {
                    child.forEach(function (c, idx) {
                        if (!c.isWrapper) {
                            c = node[key][idx] = nodeWrapper(c, node);
                        }
                        children.push(c);
                    });
                }
                else if (child) {
                    if (!child.isWrapper) {
                        child = node[key] = nodeWrapper(child, node);
                    }
                    children.push(child);
                }
            });
            
            return children;
            
        }, enumerable: true },
        /**
         * The actual node we are wrapping.
         * 
         * @property {Object} subject
         */
        subject: { get: function () {
            // update the subject with any possible properties on the wrapper
            return this.update().__node__;
        }, enumerable: true },
        
        valueOf: { value: function () {
            return this.update();
        } },
        /**
         * Get the code string for this node.
         * 
         * @method toString
         * @param {Object} opts optional options object to pass onto escodegen
         * @returns {STring}
         */
        toString: { value: function (opts) {
            return stringify(this.subject, opts);
        } }
    }
});