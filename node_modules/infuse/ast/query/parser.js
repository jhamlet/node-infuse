
var Proteus         = require("proteus"),
    Strscan         = require("pstrscan"),
    aliases         = require("./aliases"),
    Rule            = require("./rule"),
    Selector        = require("./selector"),
    ANY_SEL         = /\s*\*\s*/,
    IDENTIFIER      = /[A-Za-z][A-Za-z0-9_\-]+/,
    MEMBER_SEL      = new RegExp("\\.(" + IDENTIFIER.source + ")"),
    ATTR_SEP        = new RegExp("\\s*(" + Object.keys(Selector.COMPARATORS).map(function (key) {
        return Selector.COMPARATORS[key].source;
    }).join("|") + ")\\s*"),
    QUOTES          = /["']/,
    ATTR_START      = /\[\s*/,
    ATTR_END        = /\s*\]/,
    GROUP_SEP       = /\s*,\s*/,
    PARENT_SEP      = /\s*>\s*/,
    SIBLING_SEP     = /\s*\+\s*/,
    ANCESTOR_SEP    = /\s+/
;

/**
 * Parse a selector of the "namedIdentifier" type.
 */
function parseTypeSelector (scanner) {
    if (scanner.scan(IDENTIFIER)) {
        return new Selector("type", "=", aliases.replace(scanner.getMatch()));
    }
    else if (scanner.scan(ANY_SEL)) {
        return new Selector("type", "=", "*");
    }
}
/**
 * Parse a selector that looks like "[name = 'value']" type.
 */
function parseAttrSelector (scanner) {
    var name, op, value, quotes;
    
    if (scanner.scan(ATTR_START)) {
        name = scanner.scan(IDENTIFIER);
        
        op = scanner.scan(ATTR_SEP) ? scanner.getCapture(1) : null;
        quotes = scanner.scan(QUOTES);

        if (quotes) {
            value = scanner.scanUntil(quotes);
            value = value.slice(0, value.length - quotes.length);
            scanner.scan(ATTR_END);
        }
        else {
            value = scanner.scanUntil(ATTR_END);
            value = value.slice(0, value.length - scanner.getMatch().length);
        }
        
        return new Selector(name, op, value);
    }
}

function parseChildSelector (scanner) {
    var sel;

    if (scanner.scan(MEMBER_SEL)) {
        sel = new Selector(scanner.getCapture(1));
        sel.type = Selector.TYPES.MEMBER;
    }
    
    return sel;
}
/**
 * Parse out a selector.
 */
function parseSelector (scanner) {
    return parseChildSelector(scanner) ||
            parseTypeSelector(scanner) ||
            parseAttrSelector(scanner);
}
/**
 * Parse a full rule
 */
function parseRule (scanner) {
    var rule, sel;
    
    while ((sel = parseSelector(scanner))) {
        if (!rule) {
            rule = new Rule();
        }
        
        rule.addSelector(sel);
        
        if (scanner.scan(PARENT_SEP)) {
            sel.type = Selector.TYPES.PARENT;
        }
        else if (scanner.scan(SIBLING_SEP)) {
            sel.type = Selector.TYPES.SIBLING;
        }
        else if (scanner.scan(ANCESTOR_SEP)) {
            // it's only an ancestor selector if we haven't encountered whitespace
            // before a group separator, or the end of the query.
            if (!scanner.check(GROUP_SEP) && !scanner.hasTerminated()) {
                sel.type = Selector.TYPES.ANCESTOR;
            }
        }
    }
    
    return rule;
}
/**
 * Parse groups of rules.
 */
function parseRules (scanner) {
    var rules = [],
        rule
    ;
    
    while (!scanner.hasTerminated()) {
        rules.push(parseRule(scanner));
        scanner.scan(GROUP_SEP);
    }
    
    return rules;
}

module.exports = Proteus.Class.derive({
    
    self: {
        // Export these on the as statics. Mostly for testing.
        parseRules:         parseRules,
        parseRule:          parseRule,
        parseSelector:      parseSelector,
        parseAttrSelector:  parseAttrSelector,
        parseTypeSelector:  parseTypeSelector
    },
    
    parse: function (src) {
        var scanner = this.scanner;
        
        if (!scanner) {
            scanner = this.scanner = new Strscan(src, { chunkSize: 0 });
        }
        else {
            scanner.setSource(src);
        }
        
        return parseRules(scanner);
    }
});
