
var Proteus = require("proteus"),
    isArray = Array.isArray,
    SELECTOR_TYPES,
    COMPARISON_OPERATORS,
    COMPARISON_STRATEGIES,
    TEST_STRATEGIES
;

module.exports = Proteus.Class.derive({
    
    self: {
        /**
         * The types of selectors
         * @property {Object} TYPES
         * @static
         */
        TYPES: (SELECTOR_TYPES = {
            SELF:       "self",
            CHILD:      "child",
            SIBLING:    "sibling",
            PARENT:     "parent",
            ANCESTOR:   "ancestor"
        }),
        /**
         * The comparison operators
         * @property {Object} COMPARATORS
         * @static
         */
        COMPARATORS: (COMPARISON_OPERATORS = {
            "=":    /=/,
            "*=":   /\*=/,
            "^=":   /\^=/,
            "$=":   /\$=/,
            "~=":   /~=/,
            "|=":   /\|=/
        }),
        /**
         * The strategies to evaluate a comparison
         * @property {Object} COMPARISONS
         * @static
         * 
         *      @param {mixed} left
         *      @param {mixed} right
         *      @returns {Boolean} whether or not the left value matches the right value
         */
        COMPARISONS: (COMPARISON_STRATEGIES = {
            "=": function (left, right) {
                return left === right;
            },
            "*=": function (left, right) {
                return !!(~left.indexOf(right));
            },
            "^=": function (left, right) {
                return left.indexOf(right) === 0;
            },
            "$=": function (left, right) {
                var leftLen = left.length,
                    rightLen = right.length
                ;
                
                return left.indexOf(right) === leftLen - rightLen;
            },
            "~=": function (left, right) {
                return !!(~left.split(/\s+/).indexOf(right));
            },
            "|=": function (left, right) {
                return !!(~left.indexOf(right + "-"));
            }
        }),
        /**
         * The various test strategies for the node type
         * @property {Object} TESTS
         * 
         *      @param {Object} node the node wrapper object
         *      @param {String} attr the attribute to test
         *      @param {String} op the comparison operator to apply
         *      @param {mixed} val the value to test for
         *      @returns {Boolean|Object} returns true/false for simple matches.
         *          returns a node-wrapper instance on a successful match if 
         *          the matching context changes (parent and ancestor).
         */
        TESTS: (TEST_STRATEGIES = {
            /**
             * Tests the current node and returns true or false if a match
             */
            "self": function (node, attr, op, val) {
                var attrVal = node[attr];
                
                if (attrVal !== undefined) {
                    return val === "*" || COMPARISON_STRATEGIES[op](attrVal, val);
                }
                
                return false;
            },
            /**
             * Tests to see that the current node is a direct child of it's
             * parent's node named 'attr'
             */
            "child": function (node, attr, op, val) {
                // TODO: Implement child node selector
                return false;
            },
            /**
             * Tests to see that the current node's previous sibling has the
             * attr and value.  Returns the sibling node if successful,
             * otherwise false.
             */
            "sibling": function (node, attr, op, val) {
                var subject = node.parent,
                    childKeys = subject.childKeys,
                    attrVal,
                    relative
                ;
                
                childKeys.some(function (key) {
                    var relatives = subject[key],
                        idx
                    ;
                    
                    if (isArray(relatives)) {
                        if (~(idx = relatives.indexOf(node))) {
                            relative = relatives[idx - 1];
                            return true;
                        }
                    }

                    return false;
                });

                if (relative) {
                    attrVal = relative[attr];
                    if (attrVal !== undefined &&
                        (val === "*" || COMPARISON_STRATEGIES[op](attrVal, val))
                    ) {
                        return relative;
                    }
                }
                
                return false;
            },
            /**
             * Tests to see if the current node's parent has the attr and
             * value.  Returns the parent node if successful, otherwise
             * false.
             */
            "parent": function (node, attr, op, val) {
                var subject = node.parent,
                    attrVal = subject[attr]
                ;
                
                if (attrVal !== undefined &&
                    (val === "*" || COMPARISON_STRATEGIES[op](attrVal, val))
                ) {
                    return subject;
                }
                
                return false;
            },
            /**
             * Tests to see if any of the current node's ancestors possess the
             * attr and value. Returns the ancestor node on success, otherwise false.
             */
            "ancestor": function (node, attr, op, val) {
                var subject = node.parent,
                    attrVal
                ;
                
                while (subject) {
                    attrVal = subject[attr];
                    
                    if (attrVal !== undefined &&
                        (val === "*" || COMPARISON_STRATEGIES[op](attrVal, val))
                    ) {
                        return subject;
                    }
                    
                    subject = subject.parent;
                }
                
                return false;
            }
        })
    },
    
    init: function (attr, op, val) {
        this.attribute  = attr;
        this.comparator = op || "=";
        this.value      = val === "" || val === undefined ? "*" : val;
    },
    
    type: SELECTOR_TYPES.SELF,
    
    test: function (node) {
        return TEST_STRATEGIES[this.type](
            node,
            this.attribute,
            this.comparator,
            this.value
        );
    }
});