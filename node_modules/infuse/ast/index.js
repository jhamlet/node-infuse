
var Proteus     = require("proteus"),
    Esprima     = require("esprima"),
    Ecg         = require("escodegen"),
    FS          = require("fs"),
    NODE_KEYS   = require("./node-keys"),
    ESPRIMA_OPTION_KEYS = ["loc", "range", "raw", "tokens", "comment"],
    ECG_OPTION_KEYS = ["format", "comment"]
;

//---------------------------------------------------------------------------
// Utility functions
//---------------------------------------------------------------------------
function accumulateKeys (list, obj) {
    return list.reduce(function (acc, key) {
        acc[key] = obj[key];
        return acc;
    }, {});
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
module.exports = Proteus.Class.derive(Object.defineProperties({
    
    self: {
        NODE_TYPES: Object.keys(NODE_KEYS).reduce(function (acc, key) {
            acc[key] = key;
            return acc;
        }, {}),
        OPTIONS: Proteus.enumerate("BREAK", "SKIP")
    },
    
    init: function (opts) {
        Object.defineProperties(this, {
            /**
             * @property __source__
             * @type {String}
             * @default undefined
             * @private
             */
            __source__: { writable: true },
            /**
             * @property __subject__
             * @type {Object}
             * @default undefined
             * @private
             */
            __subject__: { writable: true }
        });
        
        this.options = Proteus.merge({}, this.options, opts || {});

        this.source = opts.file ? FS.readFileSync(opts.file, "utf8") :
                opts.code ? opts.code : "";
    },
    /**
     * Default Options
     * 
     * These are passed onto Esprima.parse -- see http://esprima.org/doc/
     * under Parsing Interface
     * 
     * @property {Object} options
     */
    options: {
        /**
         * @property {Boolean} options.loc 
         */
        loc: true,
        /**
         * @property {Boolean} options.range
         */
        range: true,
        /**
         * @property {Boolean} options.raw
         */
        raw: false,
        /**
         * @property {Boolean} options.tokens
         */
        tokens: true,
        /**
         * @property {Boolean} options.comment
         */
        comment: true,
        /**
         * @property {Object} options.format
         */
        format: {
            /**
             * @property {String} options.format.quotes
             */
            quotes: "double"
        },
        /**
         * Load source code from the file
         * 
         * @property {String} options.file
         */
        /**
         * The code to parse into the AST
         * 
         * @property {String} options.code
         */
    },
    /**
     * @method parse
     * @returns {Object} the AST
     */
    parse: function () {
        var 
            opts = this.options,
            subj
        ;
        
        /**
         * @property {Boolean} parsed
         */
        if (this.parsed) {
            return this.subject;
        }
        
        subj = Esprima.parse(
            this.source,
            accumulateKeys(ESPRIMA_OPTION_KEYS, opts)
        );
        
        // Preserve comments if the appropriate options are set
        if (opts.comment && opts.tokens) {
            subj = Ecg.attachComments(subj, subj.comments, subj.tokens);
        }
        
        this.__subject__ = subj;
        
        this.parsed = true;

        return this;
    },
    /**
     * Traverse the AST and apply the visitor's enter and leave methods as
     * appropriate
     * 
     * @method traverse
     * @param {Object} visitor
     */
    traverse: function (visitor) {
        var options     = this.constructor.OPTIONS,
            visit       = [this.subject],
            visited     = [],
            nodeTypes   = NODE_KEYS,
            isArray     = Array.isArray,
            enterFn     = typeof visitor.enter === "function" && visitor.enter,
            leaveFn     = typeof visitor.leave === "function" && visitor.leave,
            node, ret, i, j, nodes, child
        ;

        while (visit.length) {
            node = visit.pop();

            if (node) {
                ret = enterFn && enterFn.call(visitor, node, this);
                if (ret === options.BREAK) {
                    return;
                }

                if (ret !== options.SKIP) {
                    visit.push(null);
                    visited.push(node);
                    
                    nodes = NODE_KEYS[node.type];
                    i = nodes && nodes.length;
                    while (nodes && i--) {
                        child = node[nodes[i]];
                        if (child && isArray(child)) {
                            j = child.length;
                            while (j--) {
                                if (child[j]) {
                                    visit.push(child[j]);
                                }
                            }
                        } else if (child) {
                            visit.push(child);
                        }
                    }
                }
            }
            else {
                node = visited.pop();
                if (node) {
                    ret = leaveFn && leaveFn.call(visitor, node, this);
                    if (ret === options.BREAK) {
                        return;
                    }
                }
            }
        }

        return this;
    },
    
    clone: function () {
        var ast = new this.constructor(this.options);
        ast.subject = JSON.parse(JSON.stringify(this.subject));
    }
    
}, {
    /**
     * The source as computed from the resulting AST
     * 
     * @property {String} source
     */
    source: {
        get: function () {
            if (this.parsed) {
                this.__source__ = Ecg.generate(
                    this.__subject__,
                    accumulateKeys(ECG_OPTION_KEYS, this.options)
                );
            }
            return this.__source__;
        },
        set: function (src) {
            this.__source__ = src;
            this.parsed = false;
        },
        enumerable: true
    },
    /**
     * The AST object structure
     * 
     * @property {Object} subject
     */
    subject: {
        get: function () {
            if (!this.parsed) {
                this.parse();
            }
            return this.__subject__;
        },
        set: function (subj) {
            this.__subject__ = subj;
        },
        enumerable: true
    },
    
    valueOf: { value: function () {
        return this.subject;
    } },
    
    toString: { value: function () {
        return this.source;
    } }
}));
