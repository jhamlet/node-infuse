
var Proteus     = require("proteus"),
    OPTIONS     = Proteus.enumerate("BREAK", "SKIP", "REVISIT"),
    CHILD_KEYS  = require("./node-child-keys"),
    NODE_TYPES  = Object.keys(CHILD_KEYS).reduce(function (acc, key) {
        acc[key] = key;
        return acc;
    }, {})
;

/**
 * Traverses an Esprima node-like structure from an initial node.
 * 
 * It visits every node in the tree, calling the optional visitor method
 * "enter" on pre-traversal, and the visitor's "leave" method on post-traversal.
 * 
 * @function traverse
 * @param {Object} subject the node to traverse
 * @param {Object} visitor the visitor to notify when entering and leaving nodes
 *      @param {Function} enter optional function to call when a node is "entered"
 *          @param {Object} node the node being entered
 *          @returns {Undefined|Number} return OPTIONS.BREAK to stop processing at
 *              that point, or OPTIONS.SKIP to skip processing just that node.
 *      @param {Function} leave
 *          @param {Object} node the node being entered
 *          @returns {Undefined|Number} return OPTIONS.BREAK to stop processing at
 *              that point
 */
function traverse (subject, visitor) {
    var options     = traverse.OPTIONS,
        visit       = [subject],
        visited     = [],
        nodeTypes   = CHILD_KEYS,
        isArray     = Array.isArray,
        enterFn     = typeof visitor.enter === "function" && visitor.enter,
        leaveFn     = typeof visitor.leave === "function" && visitor.leave,
        node, ret, i, j, nodes, child
    ;

    while (visit.length) {
        node = visit.pop();

        if (node) {
            // pre-traversal
            ret = enterFn && enterFn.call(visitor, node);
            if (ret === options.BREAK) {
                return;
            }

            if (ret !== options.SKIP) {
                visit.push(null);
                visited.push(node);
                
                nodes = nodeTypes[node.type];
                i = nodes && nodes.length;
                while (nodes && i--) {
                    child = node[nodes[i]];
                    if (child && isArray(child)) {
                        j = child.length;
                        while (j--) {
                            if (child[j]) {
                                visit.push(child[j]);
                            }
                        }
                    } else if (child) {
                        visit.push(child);
                    }
                }
            }
        }
        else {
            // post-traversal
            node = visited.pop();
            if (node) {
                ret = leaveFn && leaveFn.call(visitor, node);
                
                if (ret === options.BREAK) {
                    return;
                }
                
                if (ret === options.REVISIT) {
                    visit.push(node);
                }
            }
        }
    }
}

module.exports = Proteus.merge(traverse, {
    /**
     * A map of all the types of nodes.
     * 
     * @property {Object} NODE_TYPES
     */
    NODE_TYPES: NODE_TYPES,
    /**
     * A map of node types to child node keys.
     * 
     * @property {Object} NODE_CHILD_KEYS
     */
    NODE_CHILD_KEYS: CHILD_KEYS,
    /**
     * Traversal control options.
     * 
     * @property {Object} OPTIONS
     */
    OPTIONS: OPTIONS
});