/*globals wrap*/

var Proteus     = require("proteus"),
    stringify   = require("infuse/ast/stringify"),
    isArray     = Array.isArray,
    CHILD_KEYS  = require("infuse/ast/node/child-keys")
;
//---------------------------------------------------------------------------
// Wrapper Utility Functions
//---------------------------------------------------------------------------
/**
 * Update the node with the passed properties.
 * 
 * @param {Object} props the properties to update on the node
 * @returns {Object} the current instance
 */
function update (props) {
    var key;
    
    if (arguments.length > 1) {
        props = Proteus.map.apply(Proteus, arguments);
    }
    
    for (key in props) {
        this[key] = props[key];
    }
    
    return this;
}
/**
 * The individual child nodes, conveniently wrapper-ized.
 * @returns {Array}
 */
function getAllChildNodes () {
    var 
        childKeys = CHILD_KEYS[this.type],
        children = [],
        key,
        nodes,
        i, n
    ;
    
    if (childKeys) {
        for (i = 0, n = childKeys.length; i < n; i++) {
            key = childKeys[i];
            nodes = this.getChildNodes(key);
            if (nodes && isArray(nodes)) {
                children.push.apply(children, nodes);
            }
            else if (nodes) {
                children.push(nodes);
            }
        }
    }
    
    return children;
}
/**
 * Get child nodes for key. If omitted, return all child nodes.
 * @param {String} key
 * @returns {Array}
 */
function getChildNodes (key) {
    var children, i;
    
    if (!arguments.length) {
        return this.getAllChildNodes();
    }
    
    children = this[key];
    if (children) {
        if (isArray(children)) {
            i = children.length;
            while (i--) {
                wrap(children[i], this);
            }
        }
        else {
            wrap(children, this);
        }
    }
    
    return children;
}
/**
 * Get the code string for this node.
 * 
 * @method toString
 * @param {Object} opts optional options object to pass onto escodegen
 * @returns {String}
 */
function toString (opts) {
    return stringify(this, opts);
}

function toJSON () {
    var obj = {},
        prop;
        
    for (prop in this) {
        obj[prop] = this[prop];
    }
    
    delete obj.parent;
    return obj;
}
//---------------------------------------------------------------------------
// Exported wrap function
//---------------------------------------------------------------------------
/**
 * Wraps a node-like object with utility functionality.
 * 
 * @function wrap
 * @param {Object} node the node to wrap
 * @param {Object} parent optional, the node's parent node.
 */
function wrap (node, parent) {
    // update the parent reference
    node.parent = parent;

    if (node.update === update) {
        return node;
    }
    
    // This is 5x faster
    node.update             = update;
    node.getChildNodes      = getChildNodes;
    node.getAllChildNodes   = getAllChildNodes;
    node.toString           = toString;
    node.toJSON             = toJSON;
    // than this
    // Object.defineProperties(node, {
    //     update:              { value: update },
    //     getChildNodes:       { value: getChildNodes },
    //     getAllChildNodes:    { value: getAllChildNodes },
    //     toString:            { value: toString }
    // });
    
    return node;
}

module.exports = wrap;
