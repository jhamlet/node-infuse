/*globals wrapNode*/

var Proteus     = require("proteus"),
    stringify   = require("../stringify"),
    isArray     = Array.isArray,
    CHILD_KEYS  = require("./child-keys"),
    PROP_CACHE    = {}
;
/**
 * Make a child property definition for the given key.
 * 
 * The definitions, and the functions defined in them, are cached so we don't
 * create two functions for every node wrapper.
 * 
 * @param {String} key the property name to create the definition for
 * @returns {Object} a Object.defineProperty definition
 */
function makeChildProp (key) {
    if (!PROP_CACHE[key]) {
        PROP_CACHE[key] = {
            get: function () {
                var self = this,
                    node = this.__node__,
                    val = node[key]
                ;

                if (isArray(val)) {
                    val.forEach(function (c, idx) {
                        val[idx] = wrapNode(c, self);
                    });
                }
                else if (val) {
                    val = node[key] = wrapNode(val, self);
                }
                
                return val;
            },
            set: function (val) {
                this.__node__[key] = val;
            },
            enumerable: true,
            configurable: true
        };
    }

    return PROP_CACHE[key];
}

function attachChildAccessors (node, childKeys) {
    var i = childKeys.length,
        key
    ;
    
    while (i--) {
        key = childKeys[i];
        Object.defineProperty(node, key, makeChildProp(key));
    }
    
    return node;
}

function removeChildAccessors (node, childKeys) {
    var i = childKeys.length;
    
    while (i--) {
        delete node[childKeys[i]];
    }
    
    return node;
}
/**
 * Wraps a node-like object with utility functionality.
 * 
 * The node becomes the prototype object of the returned wrapper instance.
 * Properties applied to the wrapper will be applied to the prototype node
 * whenever the wrapper's "update" method is called.
 * 
 * @function wrapNode
 * @param {Object} node the node to wrap
 * @param {Object} parent optional, the node's parent node.
 */
function wrapNode (node, parent) {
    var wrapper, props, keys, i, len, key;
    
    if (node.isWrapper) {
        return node;
    }
    
    wrapper = Object.create(Object.create(node, wrapNode.properties), {
        /**
         * A reference to the actual node, and in this case, the prototype
         * of this wrapper
         * 
         * @property {Object} __node__
         * @private
         */
        __node__: { value: node },
        /**
         * The parent node of this node.
         * @property {Object} parent
         * @private
         */
        __parent__: { value: parent, writable: true }
    });

    return attachChildAccessors(wrapper, CHILD_KEYS[node.type]);
}

module.exports = Proteus.merge(wrapNode, {
    
    properties: {
        /**
         * @property {Boolean} isWrapper
         * @default true
         */
        isWrapper: { value: true },
        
        type: {
            get: function () {
                return this.__node__.type;
            },
            set: function (t) {
                var node = this.__node__;
                
                removeChildAccessors(this, CHILD_KEYS[node.type]);
                node.type = t;
                attachChildAccessors(this, CHILD_KEYS[t]);
            },
            enumerable: true
        },
        /**
         * Update the node with the passed properties.
         * 
         * We only copy over non-wrapper properties to the node subject.  If
         * the props object turns out to be an instance of a node-wrapper,
         * we delete any passed keys from the wrapper, so they only exist
         * on the subject.  They'll still be available on the wrapper, since
         * the wrapper's prototype is also the subject.
         * 
         * @method update
         * @param {Object} props the properties to update on the node
         * @returns {Object} the current instance
         */
        update: { value: function (props) {
            var self = this,
                subject = this.__node__,
                childKeys = this.childKeysEnum,
                isSelf
            ;
            
            if (arguments.length > 1) {
                props = Proteus.map.apply(Proteus, arguments);
            }
            
            props = props || self;
            isSelf = props === self;
            
            Object.keys(props).forEach(function (key) {
                if (key === "type") {
                    // special case the "type" key as it needs to change the
                    // child node accessors.
                    self.type = props[key];
                }
                else if (!childKeys[key]) {
                    subject[key] = props[key];
                    if (isSelf) {
                        delete props[key];
                    }
                }
            });
            
            return this;
            
        }, enumerable: true },
        /**
         * Return a JSON string of the node subject
         * 
         * @method inspect
         * @returns {String}
         */
        inspect: { value: function () {
            return JSON.stringify(this.subject, null, 4);
        }, enumerable: true },
        /**
         * The keys for this node's children
         * 
         * @property {Array[String]} childKeys
         */
        childKeys: { get: function () {
            return CHILD_KEYS[this.type];
        }, enumerable: true },
        
        childKeysEnum: { get: function () {
            return Proteus.enumerate.apply(Proteus, this.childKeys);
        }, enumerable: true },
        /**
         * The individual child nodes, conveniently wrapper-ized.
         * 
         * @property {Object} childNodes
         */
        childNodes: { get: function () {
            var node = this,
                childKeys = this.childKeys,
                children = []
            ;
            
            childKeys.forEach(function (key) {
                var child = node[key];
                
                if (isArray(child)) {
                    children.push.apply(children, child);
                }
                else if (child) {
                    children.push(child);
                }
            });
            
            return children;
            
        }, enumerable: true },
        /**
         * The actual node we are wrapping.
         * 
         * @property {Object} subject
         */
        subject: { get: function () {
            // update the subject with any possible properties on the wrapper
            return this.update().__node__;
        }, enumerable: true },
        /**
         * The parent node-wrapper reference
         * @property {Object} parent
         */
        parent: {
            get: function () {
                return this.__parent__;
            },
            enumerable: true
        },
        
        valueOf: { value: function () {
            return this.subject;
        } },
        
        toJSON: { value: function () {
            return this.subject;
        } },
        /**
         * Get the code string for this node.
         * 
         * @method toString
         * @param {Object} opts optional options object to pass onto escodegen
         * @returns {STring}
         */
        toString: { value: function (opts) {
            return stringify(this.subject, opts);
        } }
    }
});
