/*globals wrapNode*/

var Proteus     = require("proteus"),
    stringify   = require("../stringify"),
    isArray     = Array.isArray,
    CHILD_KEYS  = require("./child-keys")
;
/**
 * Wraps a node-like object with utility functionality.
 * 
 * The node becomes the prototype object of the returned wrapper instance.
 * Properties applied to the wrapper will be applied to the prototype node
 * whenever the wrapper's "update" method is called.
 * 
 * @function wrapNode
 * @param {Object} node the node to wrap
 * @param {Object} parent optional, the node's parent node.
 */
function wrapNode (node, parent) {
    if (node.isWrapper) {
        return node;
    }
    
    Object.defineProperties(node, wrapNode.properties);
    /**
     * The parent node of this node.
     * @property {Object} parent
     * @private
     */
    node.parent = parent;
    
    return node;
}

module.exports = Proteus.merge(wrapNode, {
    
    properties: {
        /**
         * @property {Boolean} isWrapper
         * @default true
         */
        isWrapper: { value: true },
        /**
         * Update the node with the passed properties.
         * 
         * We only copy over non-wrapper properties to the node subject.  If
         * the props object turns out to be an instance of a node-wrapper,
         * we delete any passed keys from the wrapper, so they only exist
         * on the subject.  They'll still be available on the wrapper, since
         * the wrapper's prototype is also the subject.
         * 
         * @method update
         * @param {Object} props the properties to update on the node
         * @returns {Object} the current instance
         */
        update: { value: function (props) {
            var 
                self = this,
                childKeys = CHILD_KEYS[this.type]
            ;
            
            if (arguments.length > 1) {
                props = Proteus.map.apply(Proteus, arguments);
            }
            
            Object.keys(props).forEach(function (key) {
                self[key] = props[key];
            });
            
            return this;
        }, enumerable: true },
        /**
         * The individual child nodes, conveniently wrapper-ized.
         * 
         * @property {Object} childNodes
         */
        childNodes: { get: function () {
            var self = this,
                childKeys = CHILD_KEYS[this.type],
                children = []
            ;
            
            if (childKeys) {
                childKeys.forEach(function (key) {
                    var child = self[key];

                    if (isArray(child)) {
                        child.forEach(function (c, idx) {
                            children.push(wrapNode(c, self));
                        });
                    }
                    else if (child) {
                        children.push(wrapNode(child, self));
                    }
                });
            }
            
            return children;
            
        }, enumerable: true },
        /**
         * Get the code string for this node.
         * 
         * @method toString
         * @param {Object} opts optional options object to pass onto escodegen
         * @returns {STring}
         */
        toString: { value: function (opts) {
            return stringify(this, opts);
        } }
    }
});
