
var 
    Proteus = require("proteus"),
    Spec    = require("./spec"),
    nutil   = require("util"),
    is      = require("./grammar")
;

//---------------------------------------------------------------------------
// Definitions
//---------------------------------------------------------------------------
new Spec("Position", {
    line:   is.a(function (val) {
        // an integer greater than or equal to 1
        return typeof val === "number" && val >= 1 && Math.floor(val) === val;
    }),
    column: is.a(function (val) {
        // an integer greater than or equal to 0
        return typeof val === "number" && val >= 0 && Math.floor(val) === val;
    })
});

new Spec("SourceLocation", {
    source: is.a("string", null),
    start:  is.a("Position"),
    end:    is.a("Position")
});

new Spec("Node", {
    type:   is.a("string"),
    loc:    is.a("SourceLocation", null)
});

new Spec("Statement", "Node");
new Spec("Declaration", "Statement");
new Spec("Pattern", "Node");
new Spec("Expression", "Pattern");
new Spec("ThisExpression", "Expression");

new Spec("Identifier", "Expression", { name: is.a("string") });

new Spec("Literal", "Expression", {
    value: is.a("string", "boolean", "number", RegExp, null)
});

new Spec("Program", "Node", {
    body: is.a.list("Statement")
});

new Spec("Function", "Node", {
    id:         is.a('Identifier', null),
    params:     is.a.list("Pattern"),
    defaults:   is.a.list("Expression"),
    rest:       is.a("Identifier", null),
    body:       is.a("BlockStatement", "Expression"),
    generator:  is.a("boolean"),
    expression: is.a("boolean")
});

new Spec("FunctionDeclaration", "Function", "Declaration");
new Spec("FunctionExpression", "Function", "Expression");
new Spec("EmptyStatement", "Statement");

new Spec("BlockStatement", "Statement", {
    body: is.a.list("Statement")
});

new Spec("ExpressionStatement", "Statement", {
    expression: is.a("Expression")
});

new Spec("IfStatement", "Statement", {
    test:       is.a("Expression"),
    consequent: is.a("Statement"),
    alternate:  is.a("Statement", null)
});

new Spec("LabeledStatement", "Statement", {
    label:  is.a("Identifier"),
    body:   is.a("Statement")
});

new Spec("BreakStatement", "Statement", {
    label:  is.a("Identifier", null)
});

new Spec("ContinueStatement", "Statement", {
    label:  is.a("Identifier", null)
});

new Spec("WithStatement", "Statement", {
    object: is.a("Expression"),
    body:   is.a("Statement")
});

new Spec("SwitchStatement", "Statement", {
    discriminant:   is.a("Expression"),
    cases:          is.a.list("SwitchCase")
    // lexical: ["boolean"]      // ES6
});

new Spec("ReturnStatement", "Statement", {
    argument: is.a("Expression")
});

new Spec("ThrowStatement", "Statement", {
    argument: is.a("Expression")
});

new Spec("TryStatement", "Statement", {
    block:      is.a("BlockStatement"),
    handlers:   is.a.list("CatchClause"),
    finalizer:  is.a("BlockStatement", null)
});

new Spec("WhileStatement", "Statement", {
    test: is.a("Expression"),
    body: is.a("Statement")
});

new Spec("DoWhileStatement", "Statement", {
    body: is.a("Statement"),
    test: is.a("Expression")
});

new Spec("ForStatement", "Statement", {
    init:   is.a("VariableDeclaration", "Expression", null),
    test:   is.a("Expression", null),
    update: is.a("Expression", null),
    body:   is.a("Statement")
});

new Spec("ForInStatement", "Statement", {
    left:   is.a("VariableDeclaration", "Expression"),
    right:  is.a("Expression"),
    body:   is.a("Statement"),
    each:   is.a("boolean")
});

new Spec("DebuggerStatement", "Statement");

new Spec("VariableDeclaration", "Declaration", {
    declarations:   is.a.list("VariableDeclarator").minimum(1),
    kind:           is.a("var", "let", "const")
});

new Spec("VariableDeclarator", "Node", {
    id:     is.a("Identifier"),
    init:   is.a("Expression", null)
});

new Spec("ArrayExpression", "Expression", {
    elements: is.a.list("Expression", null)
});

new Spec("Property", "Node", {
    key:    is.a("Literal", "Identifier"),
    value:  is.a("Expression"),
    kind:   is.a("init", "get", "set")
});

new Spec("ObjectExpression", "Expression", {
    properties: is.a.list("Property")
});

new Spec("SequenceExpression", "Expression", {
    expressions: is.a.list("Expression").minimum(2)
});

new Spec("UnaryExpression", "Expression", {
    operator: is.a("-", "+", "!", "~", "typeof", "void", "delete"),
    argument: is.a("Expression")
    // prefix: ["boolean"],
});

new Spec("BinaryExpression", "Expression", {
    operator: is.a(
        "==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>",
        "+", "-", "*", "/", "%", "|", "^", "in", "instanceof", ".."
    ),
    left:   is.a("Expression"),
    right:  is.a("Expression")
});

new Spec("AssignmentExpression", "Expression", {
    operator: is.a(
        "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=",
        ">>>=", "|=", "^=", "&="
    ),
    left:   is.a("Expression"),
    right:  is.a("Expression")
});

new Spec("UpdateExpression", "Expression", {
    operator:   is.a("++", "--"),
    argument:   is.a("Expression"),
    prefix:     is.a("boolean")
});

new Spec("LogicalExpression", "Expression", {
    operator:   is.a("||", "&&"),
    left:       is.a("Expression"),
    right:      is.a("Expression")
});

new Spec("ConditionalExpression", "Expression", {
    test:       is.a("Expression"),
    alternate:  is.a("Expression"),
    consequent: is.a("Expression")
});

new Spec("NewExpression", "Expression", {
    callee:     is.a("Expression"),
    arguments:  is.a.list("Expression")
});

new Spec("CallExpression", "Expression", {
    callee:     is.a("Expression"),
    arguments:  is.a.list("Expression")
});

new Spec("MemberExpression", "Expression", {
    object:     is.a("Expression"),
    property:   is.a("Identifier", "Expression"),
    computed :  is.a("boolean")
});

new Spec("SwitchCase", "Node", {
    test:       is.a("Expression", null),
    consequent: is.a.list("Statement")
});

new Spec("CatchClause", "Node", {
    param:  is.a("Pattern"),
    body:   is.a("BlockStatement")
    // guard: is.a("Expression", null), //Spider-monkey specific
});


console.log(nutil.inspect(Spec, false, Infinity));
