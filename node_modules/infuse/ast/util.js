
var VM          = require("vm"),
    parse       = require("./parse"),
    stringify   = require("./stringify"),
    isArray     = Array.isArray,
    RUN_CONTEXT = VM.createContext({})
;

function toNode (val) {
    var node, id, fnStr, fnAst;
    
    switch (typeof val) {
        case "number":
            node = { type: "Identifier" };
            if (isNaN(val)) {
                node.name = "NaN";
                break;
            } else if (val === Infinity){
                node.name = "Infinity";
                break;
            } // fall through if a regular number
        case "string":
        case "boolean":
            node = {
                type: "Literal",
                value: val
            };
            break;
        case "undefined":
            node = {
                type: "Identifier",
                name: "undefined"
            };
            break;
        case "object":
            if (Object.prototype.toString.call(val) === "[object Null]") {
                node = {
                    type: "Literal",
                    value: null
                };
            }
            else if (isArray(val)) {
                node = {
                    type: "ArrayExpression",
                    elements: val.reduce(function (acc, v, idx) {
                        acc[idx] = toNode(v);
                        return acc;
                    }, [])
                };
            }
            else {
                node = {
                    type: "ObjectExpression",
                    properties: Object.keys(val).reduce(function (acc, key, idx) {
                        acc[idx] = {
                            type: "Property",
                            key: {
                                type: "Identifier",
                                name: key
                            },
                            value: toNode(val[key]),
                            kind: "init"
                        };
                        return acc;
                    }, [])
                };
            }
            break;
        case "function":
            id = val.name;
            fnStr = val.toString();
            fnStr = id ? fnStr : fnStr.replace(/^function/, "function foo");
            fnAst = parse(fnStr);
            
            node = {
                type: "FunctionExpression",
                id: id || null,
                params: fnAst.body[0].params,
                body: fnAst.body[0].body
            };
            break;
    }
    
    return node;
}

function toValue (node) {
    var type = node.type;
    
    switch (type) {
        case "Literal":
            return node.value;
        case "Identifier":
            // TODO: figure out computed values...
            return node.name;
        case "ObjectExpression":
            return node.properties.reduce(function (acc, prop) {
                acc[toValue(prop.key)] = toValue(prop.value);
                return acc;
            }, {});
        case "ArrayExpression":
            return node.elements.reduce(function (acc, el, idx) {
                acc[idx] = toValue(el);
                return acc;
            }, []);
        case "FunctionDeclaration":
        case "FunctionExpression":
            VM.runInContext("foo = " + stringify(node), RUN_CONTEXT);
            // console.log(ctx);
            return RUN_CONTEXT.foo;
    }
}

module.exports = {
    toValue: toValue,
    toNode: toNode
};
