
var VM          = require('vm'),
    parse       = require('./parse'),
    stringify   = require('./stringify'),
    isArray     = Array.isArray,
    RUN_CONTEXT = VM.createContext({})
;

function toNode (val) {
    var node, props, prop, key, id, fnStr, fnAst;
    
    switch (typeof val) {
        case 'number':
            node = { type: 'Identifier' };
            if (isNaN(val)) {
                node.name = 'NaN';
                break;
            } else if (val === Infinity){
                node.name = 'Infinity';
                break;
            } // fall through if a regular number
        case 'string':
        case 'boolean':
            node = {
                type: 'Literal',
                value: val
            };
            break;
        case 'undefined':
            node = {
                type: 'Identifier',
                name: 'undefined'
            };
            break;
        case 'object':
            if (Object.prototype.toString.call(val) === '[object Null]') {
                node = {
                    type: 'Literal',
                    value: null
                };
            }
            else if (isArray(val)) {
                node = {
                    type: 'ArrayExpression',
                    elements: val.reduce(function (acc, v, idx) {
                        acc[idx] = toNode(v);
                        return acc;
                    }, [])
                };
            }
            else {
                props = [];
                for (prop in val) {
                    // TODO: handle get/set values
                    if ((key = parseInt(prop, 10))) {
                        key = {
                            type: 'Literal',
                            value: key
                        }
                    }
                    else {
                        key = {
                            type: 'Identifier',
                            name: prop
                        }
                    }

                    props.push({
                        type:   'Property',
                        key:    key,
                        value:  toNode(val[prop]),
                        kind:   'init'
                    });
                }
                node = {
                    type: 'ObjectExpression',
                    properties: props
                };
            }
            break;
        case 'function':
            id = val.name;
            fnStr = val.toString();
            fnStr = id ? fnStr : fnStr.replace(/^function/, 'function foo');
            fnAst = parse(fnStr);
            
            node = {
                type: 'FunctionExpression',
                id: id || null,
                params: fnAst.body[0].params,
                body: fnAst.body[0].body
            };
            break;
    }
    
    return node;
}

function toValue (node) {
    var type = node.type;
    
    switch (type) {
        case 'Literal':
            return node.value;
        case 'Identifier':
            // TODO: figure out computed values...
            return node.name;
        case 'ObjectExpression':
            return node.properties.reduce(function (acc, prop) {
                acc[toValue(prop.key)] = toValue(prop.value);
                return acc;
            }, {});
        case 'ArrayExpression':
            return node.elements.reduce(function (acc, el, idx) {
                acc[idx] = toValue(el);
                return acc;
            }, []);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
            VM.runInContext('foo = ' + stringify(node), RUN_CONTEXT);
            return RUN_CONTEXT.foo;
    }
    
    return node;
}

module.exports = {
    toValue: toValue,
    toNode: toNode
};
