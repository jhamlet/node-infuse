/**
 * Primary purpose of this extract is to find all the Identifiers within
 * the code that are named the same as the given definitions and replace
 * them with the defintions value.
 * 
 * In the case of a function, we call that function and use it's return value
 * as the value to insert into the ast where the function was invoked.
 */
var Extract = require('infuse/extract'),
    astUtil = require('infuse/ast/util'),
    toNode  = astUtil.toNode,
    toValue = astUtil.toValue
;

module.exports = Extract.derive({
    
    init: function (definitions) {
        var key;
        
        this.definitions = definitions;
        
        Object.defineProperty(this, '__callStack__', { value: [] });
        
        for (key in definitions) {
            this.add(key);
        }
    },
    
    add: function (key) {
        this.rules['id[name=' + key + ']'] = this.replace;
    },
    
    replace: function (node, infuser) {
        var 
            name   = node.name,
            val    = this.definitions[node.name],
            isFn   = typeof val === 'function',
            parent = node.parent
        ;
        
        if (parent.type === 'CallExpression' && parent.callee === node) {
            // Extra hoops for an Identifier under a CallExpression
            if (!isFn) {
                throw new Error('Definiton \'' + name + '\' is not a function.');
            }
            // We have to wait until the infuser is done processing the
            // parent node, to allow for correct 'infusion' of argument
            // nodes, so we listen to its 'leave' event and when it leaves
            // the parent node, we do our thing.
            this.__callStack__.push([parent, val]);
        }
        else {
            // just replace the value
            node.update(toNode(val));
        }
    },
    
    events: {
        'leave:call': function (node, infuser) {
            var 
                stack = this.__callStack__,
                current = stack[stack.length - 1],
                args
            ;
            
            if (current && current[0] === node) {
                stack.pop();
                args = node.arguments ? node.arguments.map(toValue) : [];
                node.update(toNode(current[1].apply(null, args)));
            }
        }
    }
});
