
var 
    Proteus     = require('proteus'),
    Path        = require('path'),
    EM          = require('events').EventEmitter,
    Ast         = require('infuse/ast'),
    NodeQuery   = require('infuse/ast/query'),
    //-----------------------------------------------------------------------
    // Event RegExps
    //-----------------------------------------------------------------------
    SELF_EVENT_REGEX     = /^(start|begin|end|complete)$/,
    EVENT_SELECTOR_REGEX = /^(enter|leave|visit|\*):?(.+)?$/
;

module.exports = Proteus.Class.derive(Object.defineProperties({
    
    init: function (opts) {
        this.options = opts || {};
        this.infusions = [];
        Object.defineProperties(this, {
            __config__: { value: {} },
            __astStack__: { value: [] }
        });
    },
    /**
     * Add an, optionally named, infusion to be used on AST traversal.
     * 
     * @param {Object} infusion
     *      @property {Object} infusion.rules
     *      @property {Object} infusion.events
     * @returns {Infuser} the current infuser instance
     */
    use: function (infusion) {
        this.infusions.push(infusion);
        return this;
    },
    /**
     * Get a configuration value
     * @param {String} key
     * @returns {Mixed}
     */
    get: function (key) {
        return this.__config__[key];
    },
    /**
     * Set a configuration value
     * @param {String} key
     * @param {Mixed} value
     * @returns {Infuser}
     */
    set: function (key, value) {
        this.__config__[key] = value;
        return this;
    },
    /**
     * Run the infuser against the ast parsed from filepath.
     * 
     * @param {Infuse.Ast} ast
     * @returns {Infuse.Ast} the ast instance
     */
    run: function (ast) {
        var stack = this.__astStack__,
            isComplete,
            then
        ;
        
        isComplete = stack.length === 0;

        stack.push(ast);
        
        this.notify(isComplete ? 'start' : 'begin', this);
        ast.traverse(this);
        this.notify(isComplete ? 'complete' : 'end', this);
        
        stack.pop();
        
        return ast;
    },
    /**
     * Execute the various infusions on the specified node.
     * 
     * NOTE: The original implementation cached the rules and their functions
     * for quicker retrieval when traversing, however, if the infusion added,
     * removed, or modified their rule mid-traversal, the modification
     * wouldn't be honored.  Not to mention, in the case of removal, those
     * functions would still be notified and have a chance to change the AST
     * 
     * @param {Object} node
     * @returns {Number} the number of rules executed across all infusions
     */
    exec: function (node) {
        var
            self = this,
            count = 0
        ;
        
        this.infusions.forEach(function (infusion) {
            var
                rules = infusion.rules,
                rule,
                query
            ;
            
            if (rules) {
                for (rule in rules) {
                    query = new NodeQuery(rule);
        
                    if (query.test(node)) {
                        rules[rule].call(infusion, node, self);
                        count++;
                    }
                }
            }
        });
        
        return count;
    },
    /**
     * Fire all our infusions event handlers in order, and then fire the normal event.
     * @param {String} msg
     * @param {Object} node the node instance, or the infuser instance
     * @returns {Number} the number of events executed across all infusions
     */
    notify: function (msg, node) {
        var 
            self = this,
            count = 0
        ;
        
        // Process our infusions first
        this.infusions.forEach(function (infusion) {
            var events = infusion.events,
                key
            ;
            
            if (events) {
                for (key in events) {
                    count += self._processEvent(msg, infusion, key, events[key], node);
                }
            }
        });
        // then do a regular event emission
        this.emit(msg, node, node !== this ? this : undefined);
        return count;
    },
    //-----------------------------------------------------------------------
    // Events
    //-----------------------------------------------------------------------
    /**
     * Traversal event when entering a node
     * @event enter
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event when leaving a node
     * @event leave
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event fired when entering or leaving a node
     * @event visit
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event fired when entering or leaving a node
     * @event *
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser first starts
     * @event start
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser begins to process a sub-file/AST
     * @event begin
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser finishes processing a sub-file/AST
     * @event end
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser is done processing completely
     * @event complete
     * @param {Infuser} the infuser instance
     */
    //-----------------------------------------------------------------------
    // Traversal methods
    //-----------------------------------------------------------------------
    /**
     * Our traversal enter visitor handler
     * @param {Object} node
     */
    enter: function (node) {
        // TODO: capture scope stuff...
        this.notify('enter', node);
    },
    /**
     * Our traversal leave visitor handler
     * @param {Object} node
     */
    leave: (function () {
        // capture reused variables and functions in this closure
        var currNode, nodeAlter, modified;
        // if the node is modified, we want to revisit that node
        function tempAlter () {
            nodeAlter.apply(currNode, arguments);
            modified = arguments.length > 0;
        }
        
        return function (node) {
            currNode  = node;
            nodeAlter = currNode.alter;
            modified  = false;
            currNode.alter = tempAlter;
            // allow event handlers to modify the node
            this.notify('leave', currNode);
            // before executing our infusions
            this.exec(currNode);
            // revert to the nodes regular alter method
            currNode.alter = nodeAlter;
            return modified && Ast.TRAVERSAL_OPTIONS.REVISIT;
        };
    }())
}, {
    /**
     * Get the configuration values for the infuser
     * @property {Object} config
     */
    config: { get: function () {
        return this.__config__;
    }, enumerable: true },
    /**
     * Get the currently processing AST
     * @property {Infuse.Ast} subject
     */
    subject: { get: function () {
        var stack = this.__astStack__;
        return stack[stack.length - 1];
    }, enumerable: true },
    /**
     * Alias for subject
     * @property {Infuse.Ast} ast
     */
    ast: { get: function () {
        return this.subject;
    }, enumerable: true },
    /**
     * Get the current scope
     * @property {Object} scope
     */
    scope: {
        get: function () {
            
        },
        
        set: function (s) {
            
        },
        
        enumerable: true
    },
    /**
     * Process an event message.
     * 
     * In the case of self based (node evaluates to this) events, we just
     * check to see if the msg matches the events key.  In all other's we
     * check that the event name matches the message and that if there is a
     * query that it passes too
     * 
     * @param {String} msg
     * @param {Object} scope the infusion
     * @param {String} key the event rule
     * @param {Function} fn
     * @param {Object} node a node instance, or 'this' instance
     * @returns {Number} 1 if event is executed, 0 if not
     * @private
     */
    _processEvent: { value: function (msg, scope, key, fn, node) {
        var ret = 0,
            match, name, rule, query;
        
        if (node === this && key === msg) {
            // start|begin|end|complete events
            fn.call(scope, this);
            ret = 1;
        }
        
        match = EVENT_SELECTOR_REGEX.exec(key);
        name = match && match[1];
        rule = match && match[2];
        query = rule && new NodeQuery(rule);

        if ((!query || query.test(node)) &&
            (name === msg || name === 'visit' || name === '*')
        ) {
            fn.call(scope, node, this);
            ret = 1;
        }
        
        return ret;
    } }
}));

module.exports.include(EM);
