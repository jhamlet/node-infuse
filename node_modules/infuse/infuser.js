
var Proteus     = require('proteus'),
    Path        = require('path'),
    EM          = require('events').EventEmitter,
    InfuseAst   = require('infuse/ast'),
    NodeQuery   = require('infuse/ast/query'),
    NodeVisitor
;

module.exports = Proteus.Class.derive(Object.defineProperties({
    
    init: function (opts) {
        this.infusions = [];
        this.options = opts || {};
        Object.defineProperties(this, {
            __stack__: { value: [] }
        });
    },
    /**
     * @method use
     * @param {Object} obj an object with keys of Node Queries with the value
     *      a function to call when query tests to true
     * @param {Object} scope optional, scope to use when calling the above
     *      object's methods
     */
    use: function (obj, scope) {
        var infusion = { scope: scope || obj };
        
        infusion.queries = Object.keys(obj).map(function (key) {
            return {
                query:  new NodeQuery(key),
                fn:     obj[key]
            };
        });
        
        this.infusions.push(infusion);
    },
    /**
     * Execute the various infusions on the specified node.
     * 
     * @methods exec
     * @param {Object} node
     */
    exec: function (node) {
        var self = this;
        this.infusions.forEach(function (infusion) {
            var scope = infusion.scope;
            
            infusion.queries.forEach(function (q) {
                if (q.query.test(node)) {
                    q.fn.call(scope, node, self);
                }
            });
        });
    },
    //-----------------------------------------------------------------------
    // Events
    //-----------------------------------------------------------------------
    /**
     * Traversal event when entering a node
     * 
     * @event enter
     * @param {infuse.Ast.node} the node entered
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event when leaving a node
     * @event leave
     * Traversal event when leaving a node
     * @param {infuse.Ast.node} the node left
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser first starts
     * @event start
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser begins to process a sub-file
     * @event begin
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser finishes processing a sub-file
     * @event end
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser is done processing
     * @event complete
     * @param {Infuser} the infuser instance
     */
    enter: function (node) {
        // TODO: capture scope stuff...
        this.emit('enter', node, this);
    },
    
    leave: function (node) {
        // allow traversal listeners to modify the node
        this.emit('leave', node, this);
        // before executing our infusions
        this.exec(node);
    },
    /**
     * Run the infuser against the ast parsed from filepath.
     * 
     * @method run
     * @param {String} filepath
     * @returns {Infuse.Ast} the ast instance
     */
    run: function (filepath) {
        var stack = this.__stack__,
            isComplete,
            ast
        ;
        
        ast = new InfuseAst({ file: filepath });
        stack.push(ast);
        
        isComplete = stack.length === 1;
        this.emit(isComplete ? 'start' : 'begin', this);
        ast.traverse(this);
        this.emit(isComplete ? 'complete' : 'end', this);
        
        stack.pop();
        
        return ast;
    }
}, {
    
    ast: { get: function () {
        var stack = this.__stack__;
        return stack[stack.length - 1];
    }, enumerable: true },
    
    file: { get: function () {
        return this.ast.options.file;
    }, enumerable: true},
    
    directory: { get: function () {
        return Path.dirname(this.file);
    }, enumerable: true},
    
    scope: {
        get: function () {
            
        },
        
        set: function (s) {
            
        },
        
        enumerable: true
    }
}));

module.exports.include(EM);
