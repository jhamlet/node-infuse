
var 
    Proteus     = require('proteus'),
    Path        = require('path'),
    EM          = require('events').EventEmitter,
    Ast         = require('infuse/ast'),
    NodeQuery   = require('infuse/ast/query'),
    SELF_EVENT_REGEX = /^(start|begin|end|complete)$/,
    EVENT_SELECTOR_REGEX = /^(enter|leave|visit|\*):?(.+)?$/
;

module.exports = Proteus.Class.derive(Object.defineProperties({
    
    init: function (opts) {
        this.extracts = [];
        this.options = opts || {};
        Object.defineProperties(this, {
            __astStack__: { value: [] }
        });
    },
    /**
     * Add an extract to be used on AST traversal.
     * 
     * @param {Object} extract
     *      @property {Object} extract.rules
     *      @property {Object} extract.events
     * @returns {Number} the index of the added extract
     */
    use: function (extract) {
        return (this.extracts.push(extract) - 1);
    },
    /**
     * Get an extract by id or index
     */
    get: function (id) {
        if (typeof id === 'number') {
            return this.extracts[id];
        }
        
        return this.extracts.filter(function (extract) {
            return extract.id === id;
        })[0];
    },
    /**
     * Run the infuser against the ast parsed from filepath.
     * 
     * @param {String} filepath
     * @returns {Infuse.Ast} the ast instance
     */
    run: function (filepath) {
        var stack = this.__astStack__,
            isComplete,
            ast,
            then
        ;
        
        ast = new Ast({ file: filepath });
        isComplete = stack.length === 0;

        stack.push(ast);
        
        this.notify(isComplete ? 'start' : 'begin', this);
        // then = Date.now();
        // ast.subject; // pre-generate the ast
        // console.log('%s ms to parse', Date.now() - then);
        // then = Date.now();
        ast.traverse(this);
        // console.log('%s ms to traverse', Date.now() - then);
        this.notify(isComplete ? 'complete' : 'end', this);
        
        stack.pop();
        
        return ast;
    },
    /**
     * Execute the various extracts on the specified node.
     * 
     * NOTE: The original implementation cached the rules and their functions
     * for quicker retrieval when traversing, however, if the extract added,
     * removed, or modified their rule mid-traversal, the modification
     * wouldn't be honored.  Not to mention, in the case of removal, those
     * functions would still be notified and have a chance to change the AST
     * 
     * @param {Object} node
     * @returns {Number} the number of rules executed across all extracts
     */
    exec: function (node) {
        var
            self = this,
            count = 0
        ;
        
        this.extracts.forEach(function (extract) {
            var
                rules = extract.rules,
                rule,
                query
            ;
            
            if (rules) {
                for (rule in rules) {
                    query = new NodeQuery(rule);

                    if (query.test(node)) {
                        rules[rule].call(extract, node, self);
                        count++;
                    }
                }
            }
        });
        
        return count;
    },
    /**
     * Fire all our extracts event handlers in order, and then fire the normal event.
     * @param {String} msg
     * @param {Object} node the node instance, or the infuser instance
     * @returns {Number} the number of events executed across all extracts
     */
    notify: function (msg, node) {
        var 
            self = this,
            count = 0
        ;
        
        // Process our extracts first
        this.extracts.forEach(function (extract) {
            var events = extract.events,
                key
            ;
            
            if (events) {
                for (key in events) {
                    count += self._processEvent(msg, extract, key, events[key], node);
                }
            }
        });
        // then do a regular event emission
        this.emit(msg, node, node !== this ? this : undefined);
        return count;
    },
    //-----------------------------------------------------------------------
    // Events
    //-----------------------------------------------------------------------
    /**
     * Traversal event when entering a node
     * @event enter
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event when leaving a node
     * @event leave
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event fired when entering or leaving a node
     * @event visit
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Traversal event fired when entering or leaving a node
     * @event *
     * @param {infuse.Ast.node} the node
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser first starts
     * @event start
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser begins to process a sub-file/AST
     * @event begin
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser finishes processing a sub-file/AST
     * @event end
     * @param {Infuser} the infuser instance
     */
    /**
     * Fired when the infuser is done processing completely
     * @event complete
     * @param {Infuser} the infuser instance
     */
    //-----------------------------------------------------------------------
    // Traversal methods
    //-----------------------------------------------------------------------
    /**
     * Our traversal enter visitor handler
     * @param {Object} node
     */
    enter: function (node) {
        // TODO: capture scope stuff...
        this.notify('enter', node);
        this.notify('visit', node);
        this.notify('*', node);
    },
    /**
     * Our traversal leave visitor handler
     * @param {Object} node
     */
    leave: function (node) {
        // allow event handlers to modify the node
        this.notify('leave', node);
        this.notify('visit', node);
        this.notify('*', node);
        // before executing our extracts
        this.exec(node);
    }
}, {
    /**
     * Get the currently processing AST
     * @property {Infuse.Ast} ast
     */
    ast: { get: function () {
        var stack = this.__astStack__;
        return stack[stack.length - 1];
    }, enumerable: true },
    /**
     * Get the file path of the currently processing AST
     * @property {String} file
     */
    file: { get: function () {
        return this.ast.options.file;
    }, enumerable: true },
    /**
     * Get the directory patgh of the currently processing AST
     * @property {String} directory
     */
    directory: { get: function () {
        return Path.dirname(this.file);
    }, enumerable: true },
    /**
     * Get the current scope
     * @property {Object} scope
     */
    scope: {
        get: function () {
            
        },
        
        set: function (s) {
            
        },
        
        enumerable: true
    },
    /**
     * Process an event message.
     * 
     * In the case of self based (node evaluates to this) events, we just
     * check to see if the msg matches the events key.  In all other's we
     * check that the event name matches the message and that if there is a
     * query that it passes too
     * 
     * @param {String} msg
     * @param {Object} scope the extract
     * @param {String} key the event rule
     * @param {Function} fn
     * @param {Object} node a node instance, or 'this' instance
     * @returns {Number} 1 if event is executed, 0 if not
     * @private
     */
    _processEvent: { value: function (msg, scope, key, fn, node) {
        var match, name, rule, query;
        
        if (node === this && key === msg) {
            // start|begin|end|complete events
            fn.call(scope, this);
            return 1;
        }

        match = EVENT_SELECTOR_REGEX.exec(key);
        name = match && match[1];
        rule = match && match[2];
        query = rule && new NodeQuery(rule);

        if ((!query || query.test(node)) && name === msg) {
            fn.call(scope, node, this);
            return 1;
        }
        
        return 0;
    } }
}));

module.exports.include(EM);
