
var 
    Proteus     = require("proteus"),
    FS          = require('fs'),
    Path        = require('path'),
    app         = require("./app"),
    nutil       = require("util"),
    format      = nutil.format,
    pkgPath     = Path.join(__dirname, '..', '..', 'package.json'),
    pkgInfo     = JSON.parse(FS.readFileSync(pkgPath, 'utf8')),
    minifiers   = ['uglify', 'yui', 'closure'],
    compilers   = ['coffee', 'six', 'sjs'],
    definitions,
    options
;

//---------------------------------------------------------------------------
// Utility Functions
//---------------------------------------------------------------------------
function jsonParse (str) {
    var val;
    
    try {
        val = JSON.parse(str);
    }
    catch (e) {
        val = str || true;
    }
    
    return val;
}

function define (key, val) {
    definitions = definitions || {};
    definitions[key] = val;
    return definitions;
}
//---------------------------------------------------------------------------
// Application Options
//---------------------------------------------------------------------------
options = require('commander').
    version(pkgInfo.version).
    usage('[options] INPUT_PATH [OUTPUT_PATH]').
    option(
        '-R, --no-requires',
        'do not process require statements'
    ).
    option(
        '-e, --embed',
        'embed all required modules as strings'
    ).
    option(
        '-r, --require <PATH>',
        'include file PATH as an automatic require [*]'
    ).
    option(
        '-A, --dump-ast',
        'print to STDOUT the JSON for the generated AST and then exit.'
    ).
    option(
        '-M, --dump-modules',
        'print to STDOUT the list of the required modules'
    ).
    option(
        '-i, --infusion <NAME>',
        'add NAMEd module as an infusion [*]'
    ).
    option(
        '-D, --define <SYMBOL>[=VALUE]',
        'replace the specified SYMBOL with VALUE [*]',
        function (arg) {
            var args = arg.split(/\=/);
            return define(args[0], jsonParse(args[1]));
        }
    ).
    option(
        '-d, --define-module <NAME>',
        'replace all exported properties from NAME module [*]',
        function (arg) {
            var mod = require(arg);
            
            Object.keys(mod).forEach(function (key) {
                define(key, mod[key]);
            });
            
            return definitions;
        }
    ).
    option(
        '-c, --pre-compiler <NAME>',
        'run the INPUT_PATH through NAMEd compiler before infusing [*]',
        function (arg) {
            if (!~compilers.indexOf(arg)) {
                console.error('');
                console.error("  error: unknown compiler '%s'", arg);
                console.error('  known compilers: %s', compilers.join(', '));
                console.error('');
                process.exit(1);
            }
            return arg;
        }
    ).
    option(
        '-m, --minify [NAME]',
        format('minify output using NAMEd minifier. Defaults to \'%s\'', minifiers[0]),
        function (arg) {
            if (!~minifiers.indexOf(arg)) {
                console.error('');
                console.error("  error: unknown minifier '%s'", arg);
                console.error('  known minifiers: %s', minifiers.join(', '));
                console.error('');
                process.exit(1);
            }
            return arg;
        },
        minifiers[0]
    );

//---------------------------------------------------------------------------
// Additional Usage/Help Info
//---------------------------------------------------------------------------
options.on("--help", function () {
    console.log('  Additional Usage Information:');
    console.log('');
    console.log('    [*]   option can be specified multiple times.');
    console.log('');
});
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
module.exports = options.parse(process.argv);
