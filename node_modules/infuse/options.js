
var 
    Proteus     = require('proteus'),
    FS          = require('fs'),
    Path        = require('path'),
    app         = require('./cli-app'),
    iutil       = require('./util'),
    nutil       = require('util'),
    resolve     = require('./resolve'),
    format      = nutil.format,
    pkgPath     = Path.join(__dirname, '..', '..', 'package.json'),
    pkgInfo     = JSON.parse(FS.readFileSync(pkgPath, 'utf8')),
    minifiers   = ['uglify', 'yui', 'closure'],
    processors  = ['coffee', 'six', 'sjs'],
    definitions,
    program,
    options
;

//---------------------------------------------------------------------------
// Utility Functions
//---------------------------------------------------------------------------
function define (key, val) {
    definitions = definitions || {};
    definitions[key] = val;
    return definitions;
}

function accumulator (acc) {
    acc = acc || [];
    return function () {
        acc.push.apply(acc, arguments);
        return acc;
    };
}

//---------------------------------------------------------------------------
// Program Options
//---------------------------------------------------------------------------
program = require('commander').
    version(pkgInfo.version).
    usage('[options] <INPUT_PATH> [OUTPUT_PATH]').
    // option(
    //     '-C, --no-deadcode',
    //     'do not remove \'dead\' code'
    // ).
    option(
        '-c, --comments',
        'preserve comments in the source files'
    ).
    // The following two options will be re-defined as 'definitions'
    option(
        '-D, --define <SYMBOL>[=VALUE]',
        'replace the specified SYMBOL(s) with VALUE [*]',
        function (arg) {
            var args = arg.split(/\=/);
            return define(args[0], iutil.jsonParse(args[1]));
        }
    ).
    option(
        '-d, --definitions <NAME>',
        'replace all exported properties from NAME module [*]',
        function (arg) {
            var resolved = resolve(process.cwd(), arg),
                mod = require(resolved),
                key;
            
            for (key in mod) {
                define(key, mod[key]);
            }
            
            return definitions;
        }
    ).
    option(
        '-A, --dump-ast',
        'output the JSON for the generated AST'
    ).
    option(
        '-M, --dump-modules',
        'output the list of the required modules'
    ).
    option(
        '-e, --embed',
        'embed all required modules as strings'
    ).
    // The following will be re-defined as 'infusions'
    option(
        '-i, --infusion <NAME>',
        'add NAME module as an infusion [*]',
        accumulator()
    ).
    option(
        '-m, --minify [NAME]',
        format('minify output using NAME minifier [\'%s\']', minifiers[0]),
        function (arg) {
            if (!~minifiers.indexOf(arg)) {
                console.error('');
                console.error('  error: unknown minifier \'%s\'', arg);
                console.error('  known minifiers: %s', minifiers.join(', '));
                console.error('');
                process.exit(1);
            }
            return arg;
        },
        minifiers[0]
    ).
    option(
        '-n, --nodelib <PATH>',
        'path to the local node core modules directory [*]',
        accumulator()
    ).
    option(
        '-p, --pre-process <NAME>',
        'run the INPUT_PATH through NAME processor before infusing [*]',
        function (arg) {
            if (!~processors.indexOf(arg)) {
                console.error('');
                console.error('  error: unknown processor \'%s\'', arg);
                console.error('  known processors: %s', processors.join(', '));
                console.error('');
                process.exit(1);
            }
            return arg;
        }
    ).
    // The following gets re-defined as 'modules'
    option(
        '-r, --require <NAME>',
        'include NAME module as an automatic require [*]',
        accumulator()
    ).
    option(
        '-R, --no-requires',
        'do not process require statements'
    );
//---------------------------------------------------------------------------
// Additional Usage/Help Info
//---------------------------------------------------------------------------
program.on('--help', function () {
    var pad = Array(5).join(' ');
    console.log('  Additional Usage Information:');
    ['',
     '[*] option can be specified multiple times',
     '',
     'If OUTPUT_PATH is not specified the generated output is sent to STDOUT.',
     ''
    ].forEach(function (line) {
        console.log(pad + line);
    });
});
//---------------------------------------------------------------------------
// Parse our command-line arguments
//---------------------------------------------------------------------------
options = program.parse(process.argv);
//---------------------------------------------------------------------------
// Normalize our aliases
//---------------------------------------------------------------------------
options.infile      = options.args[0];
options.outfile     = options.args[1];
options.definitions = options.definitions || options.define || definitions;
options.infusions   = options.infusion;
options.modules     = options.require;
options.processors  = processors;
options.minifiers   = minifiers;
// clean-up
delete options.define;
delete options.infusion;
delete options.require;
// console.log(options);
//---------------------------------------------------------------------------
// Required Arguments
//---------------------------------------------------------------------------
if (!options.infile) {
    console.error('');
    console.error('  error: infuse needs at least one argument');
    program.outputHelp();
    process.exit(1);
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
module.exports = options;
