/**
 * extract noun |ˈekˌstrakt|
 * 
 * a preparation containing the active ingredient of a substance in concentrated
 * form: vanilla extract | extract of chamomile.
 */
var Proteus = require('proteus');

module.exports = Proteus.Class.derive({
    
    self: {
        /**
         * On subclassing make sure the new subclass has it's own set of
         * rules and events that are linked to its superclass' ones.
         */
        inherited: function (subclass) {
            var 
                proto       = this.prototype,
                subproto    = subclass.prototype,
                protorules  = proto.rules,
                protoevents = proto.events,
                subrules    = subproto.rules,
                subevents   = subproto.events,
                prop
            ;
            
            if (subproto.hasOwnProperty('rules')) {
                subproto.rules = Object.create(protorules);
                for (prop in subrules) {
                    subproto.rules[prop] = subrules[prop];
                }
            }
            else {
                subproto.rules = Object.create(protorules);
            }
            
            if (subproto.hasOwnProperty('events')) {
                subproto.events = Object.create(protoevents);
                for (prop in subevents) {
                    subproto.events[prop] = subevents[prop];
                }
            }
            else {
                subproto.events = Object.create(protoevents);
            }
        },
        /**
         * On instantiation, make sure the current instance has an object
         * reference to its rules and events that are prototype-linked to
         * its class definition
         */
        initialize: function (instance, args) {
            instance.rules = Object.create(instance.rules);
            instance.events = Object.create(instance.events);
        }
    },
    /**
     * Rules are used to match AST nodes upon leaving a node (post-order)
     * @property {Object} rules
     */
    rules: {},
    /**
     * Events are fired during AST traversal
     * @property {Object} events
     */
    events: {
        /**
         * Event property names
         * 
         *  'enter' - fired when the infuser enters a node
         *  'leave' - fired when the infuser leaves a node
         *  'visit' - fired on both entering and leaving a node
         *  '*'     - synonymous with 'visit'
         * 
         * Events can be modified to only fire on nodes that match a certain
         * rule.  Just add a colon after the event name and then specify the
         * node rule.
         * 
         *  'enter:Identifier[name="require"]'
         *  'leave:CallExpression'
         *  'visit:VariableDeclarator'
         *  'leave:call.callee > member id[name="foo"]'
         * 
         * Infuser events.
         * 
         * These are events associated with overall Infuser processing.
         * These events are not associated with nodes, and do not accept a
         * rule after their name
         * 
         *  start    - fired when the infuser starts processing
         *  begin    - fired when the infuser begins working on a sub-file/AST
         *  end      - fired when the infuser finishes working on a sub-file/AST
         *  complete - fired when the infuser is all done
         */
    }
});
