/**
 * Primary purpose of this infusion is to find all the Identifiers within
 * the code that are named the same as the given definitions and replace
 * them with the defintions value.
 * 
 * In the case of a function, we call that function and use it's return value
 * as the value to insert into the ast where the function was invoked.
 */
var astUtil = require('infuse/ast/util'),
    toNode  = astUtil.toNode,
    toValue = astUtil.toValue,
    definitions
;

function replaceFn (node, infuser) {
    var fn  = definitions[node.name],
        args = node.arguments ? node.arguments.map(toValue) : [],
        val = fn.apply(null, args)
    ;
    node.parent.update(toNode(val));
}

function replace (node, infuser) {
    node.update(toNode(definitions[node.name]));
}
/**
 * @param {Object} definitions an object whose keys specify Identifiers
 *      to replace with the object[key] value
 * @returns {Object} the infusion to be used by the infuser
 */
module.exports = function (obj) {
    var infusion = {},
        definitions = obj || {}
    ;

    Object.keys(obj).forEach(function (name) {
        infusion['id[name=' + name + ']'] = function (node, infuser) {
            var val    = definitions[node.name],
                isFn   = typeof val === 'function',
                parent = node.parent
            ;
            
            if (parent.type === 'CallExpression' && parent.callee === node) {
                if (!isFn) {
                    throw new Error('Definiton \'' + node.name + '\' is not a function.');
                }
                // We have to wait until the infuser is done processing the parent
                // node to get any arguments for the function correctly 'infused'
                // so we start listening to it's 'leave' event and when it leaves
                // the parent node, we do our thing.
                infuser.on('leave', function leaveListener (node, infuser) {
                    var args;
                    if (node === parent) {
                        args = node.arguments ? node.arguments.map(toValue) : [];
                        val = val.apply(null, args);
                        node.update(toNode(val));
                        infuser.removeListener('leave', leaveListener);
                    }
                });
            }
            else {
                // just replace the value
                node.update(toNode(val));
            }
        };
    });
    
    return infusion;
};
