
var Infusion    = require('infuse/infusion'),
    Ast         = require('infuse/ast'),
    astUtil     = require('infuse/ast/util'),
    Infuser     = require('infuse/infuser'),
    Definitions = require('infuse/infusions/definitions'),
    Path        = require('path'),
    toNode      = astUtil.toNode,
    toValue     = astUtil.toValue,
    isArray     = Array.isArray,
    pathMap     = {},
    MODULE_TMPL
;

module.exports = Infusion.derive({
    
    init: function (opts) {
        opts = (this.options = opts || {});
        if (typeof opts.resolve !== 'function') {
            opts.resolve = require('infuse/resolve');
        }
        this.modules = [];
        this.pathMap = {};
        Object.defineProperties(this, {
            __uuid__: { value: 0, writable: true }
        });
    },
    
    REQUIRED_MODULES_LIST_KEY: 'infusion:requires:modules',

    type: 'requires',
    /**
     * Create a Module require
     * @param {String} name
     * @param {Boolean} [autoRequire=false]
     * @returns {Number} the id of the required item
     */
    addModule: function (name, autoRequire) {
        var pathMap = this.pathMap,
            infuser = this.infuser,
            opts    = this.options,
            resolve = opts.resolve,
            // TODO: Catch any exceptions for better error handling
            filepath = resolve(name, this.directory),
            modules,
            id;
        
        if (pathMap.hasOwnProperty(filepath)) {
            return pathMap[filepath];
        }
        
        modules = this.modules;
        
        id = this.__uuid__++;
        pathMap[filepath] = id;
        modules.push({
            id: id,
            name: name,
            filepath: filepath,
            ast: infuser.run(new Ast({
                file: filepath,
                parser: opts.parser,
                generator: opts.generator,
                resolve: resolve
            })),
            autoRequire: !!autoRequire
        });

        return id;
    },
    /**
     * Determine whether to add a url or a local module
     * @returns {Number} the id of the required item
     */
    require: function (name) {
        return this.addModule(name);
        // var id = URL_REGEX.test(name) ? this.addUrl(name) : this.addModule(name);
        // return id;
    },
    
    makeModule: function (req) {
        var modulePath = Path.join(__dirname, 'module-tmpl.js'),
            moduleAst = new Ast({ file: modulePath }),
            placeholderNode,
            fnNode,
            fnBlock,
            childIdx;

        // TODO: Implement Ast#clone so I do not have to read the file over and over
        // if (!MODULE_TMPL) {
        //     MODULE_TMPL = new Ast({ file: modulePath });
        // }
        // clone our template
        // moduleAst = MODULE_TMPL.clone();

        // replace all the MODULE_ID identifiers with the module id
        moduleAst.query('id[name="INFUSE_MODULE_ID"]').forEach(function (node) {
            node.alter({ type: 'Literal', value: req.id });
        });
        // We're only interested in the body of this sub-program
        fnNode = moduleAst.subject.getChildNodes('body')[0];
        fnNode.type = 'FunctionExpression';
        fnNode.id = null;
        // splice the module code into our module function
        placeholderNode = moduleAst.query('id[name=INFUSE_MODULE]')[0];
        fnBlock = fnNode.getChildNodes('body');
        childIdx = fnBlock.body.indexOf(placeholderNode);
        fnBlock.body.splice.apply(
            fnBlock.body,
            [childIdx - 1, 1].concat(req.ast.subject.getChildNodes('body'))
        );
        // return it as a property expression
        return {
            type: 'Property',
            key: toNode(req.id),
            value: fnNode,
            kind: 'init'
        };
    },
    
    get directory () {
        return this.infuser.ast.directory;
    },
    
    autoRequire: function (name) {
        if (!this._autoRequires) {
            this._autoRequires = [];
        }
        this._autoRequires.push(name);
    },
    
    processAutoRequires: function () {
        var autoRequires = this._autoRequires;
        if (autoRequires) {
            autoRequires.forEach(function (name) {
                this.addModule(name, true);
            }, this);
        }
        this._autoRequires = null;
    },
    
    events: {
        'start': function (infuser) {
            this.infuser = infuser;
            infuser.set(this.REQUIRED_MODULES_LIST_KEY, this.modules);
            this.processAutoRequires();
        },
        
        'complete': function (infuser) {
            var modules = infuser.get(this.REQUIRED_MODULES_LIST_KEY),
                appPath, appAst, ast, modulesAst, requires;
            
            if (!modules.length) {
                return;
            }
            
            appPath = Path.join(__dirname, '/app-tmpl.js');
            appAst = new Ast({ file: appPath });
            
            modulesAst = {
                type: 'ObjectExpression',
                properties: modules.
                    sort(function (modA, modB) {
                        return modA.id - modB.id;
                    }).
                    map(this.makeModule, this)
            };
            appAst.query('id[name=INFUSE_MODULES]')[0].alter(modulesAst);
            
            requires = modules.
                filter(function (mod) {
                    return mod.autoRequire;
                });
            
            if (requires.length) {
                requireAst = requires.
                    map(function (mod) {
                        return {
                            type: 'ExpressionStatement',
                            expression: {
                                type: 'CallExpression',
                                callee: {
                                    type: 'Identifier',
                                    name: 'require'
                                },
                                arguments: [
                                    {
                                        type: 'Literal',
                                        value: mod.id
                                    }
                                ]
                            }
                        };
                    });
                appAst.subject.body.push.apply(
                    appAst.subject.body,
                    requireAst
                );
            }
            
            // append the original application to the body of the requires...
            appAst.subject.body.push.apply(
                appAst.subject.body,
                infuser.ast.subject.body
            );
            // and replace the infuser's ast with that one
            infuser.subject.options.ast = appAst;
        }
    },
    
    rules: {
        'call.callee > id[name="require"]': function (node, infuser) {
            var callNode = node.parent,
                // Node only allows one argument to 'require'
                arg = callNode.arguments[0];
            
            switch (arg.type) {
            case 'Literal':
                arg.alter('value', this.require(arg.value));
                break;
            case 'Identifier':
                // TODO: Use scope and determine module
                break;
            }
        }
    }
});
